#!/usr/bin/env ruby


require 'fileutils'
require 'Yk/debug2'

if ARGV.size != 2
	STDERR.write "USAGE: cp_noerror SRC_DIR DEST_DIR"
	exit 1
end


SRC = ARGV[0]
DST = ARGV[1]


MSG_D = "/tmp/cp_noerror"


FileUtils.mkdir_p MSG_D

$ef = "#{MSG_D}/cp_noerror.#{$$}"

newest = Time.at(0)
newestF = nil


OKList = {}

Dir.glob MSG_D + "/cp_noerror.*.ok" do |e|
	File.open e do |fr|
		fr.each_line do |ln|
			if ln =~ /^.*\|(.*):[^:]*$/
				OKList[$1] = true
			end
		end
	end
#	if File.mtime(e) > newest
#		newest = File.mtime(e)
#		newestF = e
#	end
end


#if File.exist? newestF
#	File.open newestF do |fr|
#		fr.each_line do |ln|
#			if ln =~ /^.*\|(.*):[^:]*$/
#				OKList[$1] = true
#			end
#		end
#	end
#end


def out f, m, *fs
	m = Time.now.to_s + "|" + f + ":" + m + ".\n"
	msgpane
	print m
	["", *fs].each do |ext|
		File.append $ef + ext, m
	end
end

def msg f, m
	out f, m
end

def err f, m
	out f, m, ".err"
	print "\n\n\n\n\n\n\n\n\n\n"
	print "\033[u"
end

def ok f
	out f, "Processed successfully", ".ok"
end


class String
	def / arg
		if arg[0] == "/"
			arg
		elsif self.empty?
			arg
		elsif arg == "" || arg == nil
			if self[-1] == "/"
				self.chop
			else
				self
			end
		else
			if self[-1] == "/"
				self + arg
			else
				self + "/" + arg
			end
		end
	end
end


class File
  class << self
    def append(path, content)
      File.open(path, "a") { |f| f << content }
    end
  end
end

def msgpane
	print "\033[u"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[B\033[K"
	print "\033[u"
	STDOUT.flush
end


def each_dir dir = ""
	if OKList[dir]
		msg dir, "Already processed"
		return
	end
	msg(dir == "" ? "." : dir, "processing directory")
	s = SRC / dir
	d = DST / dir
	if File.symlink?(s) || !File.directory?(s)
		STDERR.write "ERROR: The source path, '#{s}' is not a directory\n"
		exit 1
	end
	begin
		if File.symlink?(d) || (File.exist?(d) && !File.directory?(d))
			FileUtils.rm_f d
		end
		FileUtils.mkdir_p d
		stat = File.stat(s)
		FileUtils.chmod(stat.mode, d)
		FileUtils.chown(stat.uid, stat.gid, d)
		FileUtils.touch(d, mtime: stat.mtime)
	rescue
		err dir, "Failed to mkdir/copy attributes (#{$!}). Skipping"
		return
	end
	begin
		failed = false
		Dir.foreach s do |f|
			sf = s / f
			df = d / f
			t = dir / f
			if OKList[t]
				msg t, "Already processed"
				next
			end
			if f != "." && f != ".."
				begin
					if !File.symlink?(sf) && File.directory?(sf)
						each_dir t
					else
						msg t, "processing non-directory entry"
						if File.symlink?(sf) || File.symlink?(df)
							FileUtils.rm_f(df)
						end
						if !File.symlink?(sf) && File.file?(sf)
							begin
								if File.symlink?(df) || !File.file?(df)
									FileUtils.rm_f df
								end
								if !system "/usr/bin/rsync", "-avc", "--info=progress2", sf, df
									err t, "Failed to rsync #{sf} #{df}. Skipping"
								end
							rescue => e
								failed = true
								err t, "Failed to copy entry (#{e}:#{e.backtrace[0]}). Skipping"
							end
						else
							if !system "/bin/cp", "-af", sf, df
								failed = true
								err t, "Failed to copy entry ('/bin/cp -af #{sf} #{df}', failed). Skipping"
							end
						end
					end
				rescue => e
					failed = true
					err t, "Failed to stat entry (#{e}:#{e.backtrace[0]}). Skipping"
				end
			end
		end
	rescue => e
		err dir, "Failed to read directory entry (#{e}:#{e.backtrace[0][0]}). Skipping"
		return
	end
	if !failed
		ok dir
	end
end

print "\n\n\n\n\n\n\n\n\n\n"
STDOUT.flush

print "\033[10A\033[s"
STDOUT.flush

each_dir

